//#include "stdafx.h"
#include "../inc/global.h"
 
extern void BatChargeTest();
int GetAmount(u8 *pAmt)
{
	int ret;
	char buf[32], temp[32];
	
	memset( buf, 0, sizeof( buf));
	memset( temp, 0, sizeof( temp));
	
	while(1)
	{
		memset(buf, 0, sizeof(buf));
		ret = GetScanf(MMI_POINT, 1, 12, buf, 60, LINE3, LINE3, MAX_LCDWIDTH);
		if(ret == ENTER)
		{
			memset(temp, 0x30, 12-buf[0]);
			strcpy(&temp[12-buf[0]], &buf[1]);
			AscToBcd_Api(pAmt, temp, 12);
			return 0;
		}
		else
		{
			return E_TRANS_CANCEL;
		}
	}
}
 
int GetSysRefNo(char *pSysRefNO)
{
	int ret;
	char Tempbuf[32];
	
	memset(Tempbuf, 0, sizeof(Tempbuf));
	
	ScrClrLine_Api(LINE2, LINE5);
    	ScrDisp_Api(LINE2, 0, "input REF code:", CDISP);  //REF:reference
	memset(Tempbuf, 0, sizeof(Tempbuf));
	ret = GetScanf(MMI_NUMBER|MMI_LETTER, 12, 12, Tempbuf, 60, LINE4, LINE4,16);
	if(ret == ENTER)			// 
	{
		sprintf(pSysRefNO,"%012s", &Tempbuf[1]);
	}
	else
		return ret;
	
	return 0;
}
 

int EnterPIN(u8 flag)
{
	int ret;
	u8 DesFlag;
	u8 temp[128];
	char dispbuf[32];
	
	memset(dispbuf,0,sizeof(dispbuf));
	ScrClrLine_Api(LINE2, LINE5);
	if(flag != 0)
		ScrDisp_Api(LINE2, 0, "Password Is Wrong, Please Input Again:", LDISP);
	else 
		ScrDisp_Api(LINE2, 0, "Please Input Password:", LDISP);

	if(gCtrlParam.DesType == 1) //Des
		DesFlag = 0x01;
	else
		DesFlag = 0x03;

	if(gCtrlParam.pinpad_type == PIN_PP)
	{
		ret = PPReadPinPadSn_Api(temp);
		if(ret == 0)
        	ret = PPGetPwd_Api(gCtrlParam.PinKeyIndes, 4, 8, PosCom.stTrans.MainAcc, PosCom.sPIN, DesFlag);
	}
	else
	{
		ret = PEDGetPwd_Api(gCtrlParam.PinKeyIndes, 4, 8, PosCom.stTrans.MainAcc, PosCom.sPIN, DesFlag);
	}
	
	if(ret != 0)
		return E_TRANS_CANCEL;
	
	if(memcmp(PosCom.sPIN, "\0\0\0\0\0\0\0\0", 8) == 0)
		PosCom.stTrans.EntryMode[1] = PIN_NOT_INPUT;
	else
		PosCom.stTrans.EntryMode[1] = PIN_HAVE_INPUT;

	ret = PPReadPinPadSn_Api(temp);
	if(ret == 0)
		SPadSignExTest();
	else
//		SPadSignTest();
	
	return 0;
}
 
void DispTradeTitle(u8 TranId)
{
	char tradename[32];

	memset(tradename, 0, sizeof(tradename));
	ConverTranNameCh(PosCom.stTrans.Trans_id, tradename);
	if(strlen(tradename) > 2)	
	{
		ScrClrLine_Api(LINE1, LINE1);
		DispTitle(tradename);
	}
}
 
int ConverTranNameCh(u8 TranId, char *TransName)
{
	switch(TranId) 
	{									
	case POS_SALE:	
		strcpy(TransName,"Sale"); 	
		break;
	case POS_QUE:				
		strcpy(TransName,"Balance Inquiry"); 
		break;
	case POS_SALE_VOID:	
		strcpy(TransName,"Void"); 
		break;
	default	:					
		strcpy(TransName,"");				
		break;

	}
	return 0;
}

int ConverTranNameEn(u8 TranId, char *TransName)
{
	switch(TranId) 
	{
		case POS_SALE:					strcpy(TransName,"(SALE)"); 				break;
		case POS_SALE_VOID:				strcpy(TransName,"(VOID)"); 				break;
		default:						strcpy(TransName,"");						break;
	}
	return 0;
} 
void ConvErrCode(int errCode, char *szErrInfo)
{	
	switch(errCode) 
	{
		case	E_MAC:				strcpy(szErrInfo,"Mac error"); 					break;
		case	E_SYS:				strcpy(szErrInfo,"system error"); 						break;

		case	E_FAILURE:	
			strcpy(szErrInfo,"Transaction Failed "); 			break;				
		case	E_TRANS_CANCEL:	
				strcpy(szErrInfo,"Transaction Cancelled "); 						break;			
		case	E_NO_TRANS:			strcpy(szErrInfo,"no trade"); 						break;
		case	E_SEND_PACKET:		strcpy(szErrInfo,"send failed"); 						break;
		case	E_RECV_PACKET:		strcpy(szErrInfo,"receive failed"); 						break;
		case	E_RESOLVE_PACKET:	strcpy(szErrInfo,"unpake failed"); 						break;
		case	E_REVERSE_FAIL:		strcpy(szErrInfo,"reversal failed"); 						break;
		case	E_NO_OLD_TRANS:		strcpy(szErrInfo,"original trade not exist"); 					break;
		case	E_TRANS_VOIDED:		strcpy(szErrInfo,"original trade canceled"); 					break;
		case	E_ERR_SWIPE:		strcpy(szErrInfo,"swip failed"); 						break;
		case	E_MEM_ERR:			strcpy(szErrInfo,"file operate failed"); 					break;
		case	E_PINPAD_KEY:		strcpy(szErrInfo,"key error"); 						break;
	//	case	E_TIP_AMOUNT:		strcpy(szErrInfo,"小费金额超限"); 					break;
	//	case	E_HAVE_ADJ:			strcpy(szErrInfo,"交易已经调整过");					break;
		case	E_FILE_OPEN:		strcpy(szErrInfo,"open file failed"); 					break;
		case	E_FILE_SEEK:		strcpy(szErrInfo,"seek file failed"); 					break;
		case	E_FILE_READ:		strcpy(szErrInfo,"read file failed"); 						break;
		case	E_FILE_WRITE:		strcpy(szErrInfo,"write file failed"); 						break;
		case	E_MAKE_PACKET:		strcpy(szErrInfo,"pack eror"); 						break;
		case	E_ERR_CONNECT:		strcpy(szErrInfo,"connect failed"); 						break;
		case	E_TRANS_FAIL:
				strcpy(szErrInfo,"Transaction Failed "); 						break;				
		case	E_REVTIMEOUT:
				strcpy(szErrInfo,"Time Out! "); 						break;				
		case	E_PPNORESP:			strcpy(szErrInfo,"no response!");				break;
	//
		case	ERR_EMVRSP:			strcpy(szErrInfo,"response code error!");					break;
		case	ERR_APPBLOCK:		strcpy(szErrInfo,"APP was locked!");						break;
		case	ERR_NOAPP:			strcpy(szErrInfo,"EMV APP not exist!");				break;
		case	ERR_USERCANCEL:		strcpy(szErrInfo,"trade canceled!");						break;
		case	ERR_TIMEOUT:		strcpy(szErrInfo,"operate timeout!");					break;
		case	ERR_EMVDATA:		strcpy(szErrInfo,"card data error!");					break;
		case	ERR_NOTACCEPT:		strcpy(szErrInfo,"trade not accept!");					break;
		case	ERR_EMVDENIAL:		strcpy(szErrInfo,"emv denial!");					break;
		case	ERR_KEYEXP:			strcpy(szErrInfo,"key expired!");						break;
		case	ERR_NOPINPAD:		strcpy(szErrInfo,"pinpad not exist!");		break;
		case	ERR_NOPIN:			strcpy(szErrInfo,"no pin!");	break;
		case	ERR_CAPKCHECKSUM:	strcpy(szErrInfo,"capk check failed!");		break;
		case	ERR_NOTFOUND:		strcpy(szErrInfo,"data not found!");		break;
		case	ERR_NODATA:			strcpy(szErrInfo,"data not found!");		break;
		case	ERR_OVERFLOW:		strcpy(szErrInfo,"memory overflow!");						break;
		//case	ERR_NOTRANSLOG:		strcpy(szErrInfo,"no record!");					break;
		//case	ERR_NORECORD:		strcpy(szErrInfo,"no record!");						break;
		//case	ERR_NOLOGITEM:		strcpy(szErrInfo,"record error!");					break;
		case	ERR_ICCRESET:		strcpy(szErrInfo,"IC reset failed!");					break;
		case	ERR_ICCCMD:			strcpy(szErrInfo,"IC command failed!");					break;
		case	ERR_ICCBLOCK:		strcpy(szErrInfo,"IC card locked!");						break;
		//case	ERR_ICCNORECORD:	strcpy(szErrInfo,"IC card no record!");					break;
		//case	ERR_GENAC1_6985:	strcpy(szErrInfo,"GEN AC return 6985!");			break;

		default	:					
				strcpy(szErrInfo,"Transaction Failed "); 						break;				
	}	
	return;
}
 
int WaitEvent(void)
{
	u8 Key, Temp[32];
	char Time[32], TimeTemp[40], Dispbuf[32];
	u32 TimerId;
	int IsElectric;

	memset(Temp		, 0, sizeof(Temp));
	memset(Time		, 0, sizeof(Time));
	memset(Dispbuf	, 0, sizeof(Dispbuf));
	memset(TimeTemp	, 0, sizeof(TimeTemp));

	MagReset_Api();
	TimerId = TimerSet_Api();
	while(1)
	{
#if ((defined V71_MACHINE) || (defined V36H_MACHINE) || (defined V80B_MACHINE))
		if(TimerCheck_Api(TimerId , 30*1000) == 1)
		{
			SysPowerStand_Api();
			return 0xfe;
		}
#endif 
		BatChargeTest();
		GetSysTime_Api(Temp);					 
		if( memcmp(TimeTemp, Temp, 7) != 0 )
		{ 
			BcdToAsc_Api(Time, Temp, 14);
			MakeTimeDispBuf(Dispbuf, Time);
			ScrClrLineRam_Api(LINE7, LINE7);
			ScrDispRam_Api(LINE7, 0, Dispbuf, CDISP);
			ScrBrush_Api();
			memcpy(TimeTemp, Temp, 8);
		}
		
		Key = GetKey_Api();
		Key = TelephoneEvent_Api((int)Key);
		if(Key != 0)
			return Key;
	}
	return 0;
}

 void TraceNoInc(void)
{
	gCtrlParam.lTraceNo += 1;
	if(gCtrlParam.lTraceNo<=0 || gCtrlParam.lTraceNo > 999999)
	{
		gCtrlParam.lTraceNo = 1;
	}
	SaveCtrlParam();
} 


void DispAllVersion(void)
{
	u8 i=0, StrTemp[50], VersionLeng=0, OutBufer[1024*4];
	int VersionNum, Point;
	
	memset(StrTemp	, 0, sizeof(StrTemp));
	memset(OutBufer	, 0, sizeof(OutBufer));
	
	ScrCls_Api();
	VersionNum = 0;
	Point = 0;
	DispTitle("LIB VERSION");
	if( GetVersion_Api(OutBufer, &VersionNum) != 0x00 )
	{
		ScrDisp_Api(LINE4, 0, "read failed",FDISP);
		WaitAnyKey_Api(2);
		return;
	}
	
	ScrBackLight_Api(VersionNum*30);	
	for (i = 0; i < VersionNum; i++)
	{
		memset(StrTemp, 0, sizeof(StrTemp));
		memcpy(StrTemp, &OutBufer[Point], 20);
		Point += 20;
		ScrDisp_Api(LINE2, 0, (char*)StrTemp, FDISP);
		memset(StrTemp, 0, sizeof(StrTemp));
		VersionLeng = OutBufer[Point];
		Point += 1;
		memcpy(StrTemp, &OutBufer[Point], VersionLeng);
		ScrDisp_Api(LINE3, 0, (char*)StrTemp, FDISP);
		Point += VersionLeng;
		VersionLeng = 0;
		WaitAnyKey_Api(60);
		ScrCls_Api();
	}
}

void CCBLogo(void)
{
	//----------------------------------------
	// width X hight （pixel）: 270 x 75
	//----------------------------------------
	const char BocomLogo[2700] = 
	{
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x40, 0x40, 
		0x20, 0x20, 0x20, 0x30, 0x10, 0x10, 0x18, 0x18, 0x18, 0x1C, 0x1C, 0x1C, 0x1C, 0x3C, 0x3C, 0x3C, 
		0x3C, 0x7C, 0x7C, 0xF8, 0xF8, 0xF8, 0xF8, 0xF0, 0xF0, 0xE0, 0xC0, 0x80, 0x00, 0x00, 0x00, 0x00, 
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
		0x00, 0x80, 0xC0, 0xC0, 0xE0, 0x70, 0x30, 0x18, 0x08, 0x0C, 0x84, 0x86, 0xC2, 0xE2, 0xF1, 0xF1, 
		0xF9, 0xF8, 0xFC, 0xFC, 0xFE, 0xFE, 0xFE, 0xFE, 0xFE, 0xFF, 0xFF, 0xFF, 0x7F, 0x3F, 0x3E, 0x3E, 
		0x3E, 0x3C, 0x3D, 0x3B, 0x3F, 0x3F, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFE, 0xF8, 0xE0, 0x00, 0x00, 
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 
		0xC0, 0xC0, 0xE0, 0xF0, 0xF0, 0xF8, 0xF8, 0xFC, 0xFC, 0xFC, 0xFC, 0xFE, 0xFE, 0xFE, 0xFE, 0xFE, 
		0xFE, 0xFE, 0xFE, 0xFE, 0xFE, 0xFE, 0xFE, 0xFE, 0xFE, 0x1E, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
		0xF0, 0xFC, 0xFE, 0xFE, 0xFE, 0xFE, 0xFE, 0xFE, 0xFE, 0xFE, 0x1E, 0x02, 0x00, 0x00, 0x00, 0x00, 
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x60, 0x7C, 
		0x7E, 0x7E, 0x7E, 0x7E, 0x7E, 0xFE, 0x7E, 0xFE, 0x3E, 0x06, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0xC0, 0xF0, 0xF8, 0x7C, 0x3E, 0x0F, 0x07, 
		0x03, 0x01, 0xC0, 0xE0, 0xF8, 0xFC, 0xFE, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 
		0x9F, 0x8F, 0x8F, 0x8F, 0x8F, 0x8F, 0x8F, 0x8F, 0x8F, 0x8F, 0x8E, 0x8C, 0x8C, 0x8C, 0x8C, 0x8C, 
		0x8C, 0x8C, 0x8C, 0x8C, 0x8C, 0xBC, 0xBC, 0xBC, 0xBC, 0xBC, 0xBC, 0xBC, 0x1C, 0x00, 0x00, 0x00, 
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0xE0, 0xF0, 0xFC, 0xFE, 0xFF, 0xFF, 0xFF, 0xFF, 
		0xFF, 0x7F, 0x3F, 0x1F, 0x0F, 0x07, 0x03, 0x03, 0x01, 0x01, 0x01, 0xC0, 0xE0, 0xE0, 0xF0, 0xF0, 
		0xF0, 0xF0, 0xF0, 0xF0, 0xF0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0xF0, 0xF0, 0xF0, 0xF0, 
		0xF0, 0xF0, 0xF0, 0xF0, 0xF0, 0xF0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0xC0, 0xC0, 
		0xC0, 0xE0, 0xE0, 0xE0, 0xE0, 0xF0, 0xF0, 0xF0, 0xF0, 0xF0, 0xF0, 0xF0, 0xF0, 0xF0, 0xF0, 0xF0, 
		0xF0, 0xF0, 0xF0, 0xF0, 0x70, 0x00, 0x00, 0x00, 0x00, 0x00, 0xF0, 0xF0, 0xF0, 0xF0, 0xF0, 0xF0, 
		0xF0, 0xF0, 0xF0, 0xF0, 0x30, 0x00, 0x00, 0x00, 0x00, 0x00, 0xF0, 0xF0, 0xF0, 0xF0, 0xF0, 0xF0, 
		0xF0, 0xF0, 0xF0, 0xF0, 0xF0, 0xF0, 0xF0, 0xF0, 0xF0, 0xF0, 0xF0, 0xF0, 0xF0, 0xF0, 0xF0, 0xF0, 
		0xE0, 0xE0, 0xE0, 0xC0, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0xC0, 
		0xC0, 0xE0, 0xE0, 0xE0, 0xF0, 0xF0, 0xF0, 0xF0, 0xF0, 0xF0, 0xF0, 0xF0, 0xF0, 0xF0, 0xF0, 0xF0, 
		0xF0, 0xF0, 0xF0, 0xF0, 0xF0, 0xE0, 0xE0, 0xC0, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
		0x00, 0x00, 0x00, 0xE0, 0xF8, 0xFE, 0xFF, 0x1F, 0x07, 0x01, 0x00, 0x00, 0x80, 0xF0, 0xFE, 0xFF, 
		0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x7F, 0x7F, 0x63, 0x61, 0x61, 0x61, 0x61, 
		0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 
		0xE1, 0xE3, 0xE7, 0xE7, 0xE7, 0xE7, 0xE7, 0xE7, 0x27, 0x07, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 
		0xC0, 0xF0, 0xF8, 0xFE, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x7F, 0x1F, 0x0F, 0x03, 0x01, 0x00, 
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0xF0, 0xFE, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 
		0x7F, 0x0F, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0xF8, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 
		0xFF, 0xFF, 0x0F, 0x01, 0x00, 0x00, 0x00, 0xE0, 0xFC, 0xFE, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 
		0xFF, 0xEF, 0x87, 0x83, 0x03, 0x03, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 
		0x01, 0x01, 0x00, 0x00, 0x00, 0x00, 0xF0, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 
		0x1F, 0x01, 0x00, 0x00, 0x00, 0x00, 0xF0, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 
		0x0F, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x0F, 0x1F, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 
		0xFF, 0xFF, 0xFF, 0x1E, 0x00, 0x00, 0x00, 0x00, 0xE0, 0xF8, 0xFE, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 
		0xFF, 0xFF, 0x7F, 0x1F, 0x0F, 0x07, 0x03, 0x01, 0x01, 0x01, 0x01, 0x03, 0x0F, 0xFF, 0xFF, 0xFF, 
		0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x3E, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xF0, 
		0xFF, 0xFF, 0xFF, 0xFF, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 
		0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x1C, 0x1C, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 
		0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x58, 0x78, 0x78, 0x78, 0x79, 0x79, 0x79, 
		0x79, 0x79, 0x39, 0x19, 0x01, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0xE0, 0xF0, 0xFC, 0xFE, 0xFF, 0xFF, 0xFF, 
		0xFF, 0xFF, 0x7F, 0x3F, 0x1F, 0x07, 0x03, 0x00, 0x80, 0xE0, 0xF0, 0xF0, 0xF0, 0xF0, 0xF0, 0xF0, 
		0xF0, 0xF0, 0xF0, 0xF8, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x7F, 0x07, 0x00, 0x00, 
		0x00, 0x00, 0x00, 0xC0, 0xF8, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x7F, 0x0F, 0x00, 
		0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x07, 0x0F, 0x1F, 0x3F, 0x3F, 0x3F, 0x7F, 0x7F, 0x7F, 0xFF, 
		0xFF, 0xFF, 0xFF, 0xFF, 0xFE, 0xFE, 0xFE, 0xFC, 0xFC, 0xF8, 0xF0, 0x80, 0x00, 0x00, 0x00, 0x00, 
		0x00, 0x80, 0xF8, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x0F, 0x01, 0x00, 0x00, 
		0x00, 0x00, 0xF0, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x7F, 0x0F, 0x00, 0x00, 0x00, 
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xF0, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x3F, 
		0x03, 0x00, 0x00, 0x00, 0xF0, 0xFE, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x1F, 0x03, 
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0xE0, 0xFE, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 
		0xFF, 0xFF, 0xFF, 0x1F, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x1F, 0xFF, 0xFF, 
		0xFF, 0xFF, 0xFE, 0xF8, 0xE0, 0xC0, 0x80, 0x00, 0x03, 0x0F, 0x1F, 0x3F, 0x7F, 0x7F, 0xFF, 0xFF, 
		0xFF, 0xFF, 0xFF, 0xFF, 0xF8, 0xF0, 0xE0, 0xC0, 0xC0, 0xC3, 0xC3, 0xC3, 0xC3, 0xC3, 0xC3, 0xE3, 
		0xE3, 0xF3, 0xFB, 0xF9, 0xFD, 0xFF, 0xFF, 0xFF, 0x7F, 0x3F, 0x1F, 0x0F, 0x07, 0x03, 0x01, 0x00, 
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
		0x80, 0xC0, 0xF0, 0xF8, 0xFE, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x7F, 0x1F, 0x0F, 0x03, 0x01, 
		0x00, 0x00, 0x00, 0x00, 0x04, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0xC7, 0xFF, 
		0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x7F, 0x07, 0x00, 0x00, 0x00, 0x00, 0x00, 0xC0, 
		0xFC, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x7F, 0x07, 0x00, 0x00, 0x00, 0x00, 0x80, 
		0xC0, 0xC0, 0xE0, 0xE0, 0xE0, 0xE0, 0xE0, 0xE0, 0xE0, 0xE0, 0xE0, 0xE0, 0xE0, 0xE0, 0xF0, 0xFB, 
		0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x7F, 0x3F, 0x07, 0x00, 0x00, 0x00, 0xC0, 0xF8, 0xFF, 
		0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x0F, 0x00, 0x00, 0x00, 0x00, 0x80, 0xF8, 0xFF, 
		0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x7F, 0x07, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
		0x00, 0x00, 0xE0, 0xFE, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x7F, 0x03, 0x00, 0x00, 0x00, 
		0x00, 0x7E, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xE0, 0xC0, 0x80, 0x80, 
		0xC0, 0xC0, 0xE0, 0xF0, 0xF8, 0xFE, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x7F, 0x1F, 0x07, 
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0x0F, 0x1F, 
		0x3F, 0x7F, 0x7F, 0xFF, 0xFF, 0xFF, 0xFE, 0xFE, 0xFC, 0xFC, 0xFC, 0xFC, 0xF8, 0xF8, 0xF9, 0xF9, 
		0xF9, 0xFD, 0xFD, 0xFD, 0xFD, 0xFD, 0xFE, 0xFF, 0xFF, 0x7F, 0x7F, 0x7F, 0x3F, 0x1F, 0x1F, 0x0F, 
		0x0F, 0x07, 0x03, 0x03, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x04, 0x06, 0x07, 0x07, 
		0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x06, 0x07, 0x07, 0x07, 0x07, 
		0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x04, 0x07, 0x07, 0x07, 
		0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x00, 0x00, 0x00, 0x00, 0x00, 0x07, 0x07, 0x07, 0x07, 
		0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 
		0x03, 0x03, 0x01, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x04, 0x07, 0x07, 0x07, 0x07, 0x07, 
		0x07, 0x07, 0x07, 0x07, 0x07, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x07, 0x07, 0x07, 0x07, 0x07, 
		0x07, 0x07, 0x03, 0x03, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x06, 
		0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
		0x01, 0x03, 0x03, 0x07, 0x07, 0x07, 0x07, 0x0F, 0x0F, 0x0F, 0x0F, 0x0F, 0x0F, 0x0F, 0x0F, 0x0F, 
		0x0F, 0x0F, 0x07, 0x07, 0x07, 0x07, 0x07, 0x03, 0x03, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
		0x00, 0x00, 0x00, 0x01, 0x01, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 
		0x03, 0x01, 0x01, 0x01, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
	};

	ScrDrLogoxyRam_Api(270, 75, 30, 20, BocomLogo);
}

void SetSignPad(void)
{
	int ret;
	char Tempbuf[32];

	const char *setSign_menu2[] = {
		"0.NONE",
		"1.built-in",
		"2.external"
	};

	//  gCtrlParam.SupportSignPad
	sprintf(Tempbuf, "current %d", gCtrlParam.SupportSignPad);
	ret = ShowMenuItem(Tempbuf, setSign_menu2, 3, DIGITAL0, DIGITAL2, gCtrlParam.SupportSignPad+1, 60);
	if( (ret >= DIGITAL0)&&(ret <= DIGITAL2) )
	{
		gCtrlParam.SupportSignPad = ret-DIGITAL0;
		SaveCtrlParam();    
	}
}
int SettingMenu(void)
{
	int key;

	char maintitle[] = "Settings";
	const char *main_menu[] = {
		"1.Set PINPAD",
		"2.Set SignPad",
		"3.Set Key"
	};
	while(1)
	{
		key = ShowMenuItem(maintitle, main_menu, 3, DIGITAL1, DIGITAL3, 0, 60);
		switch(key)
		{
		case DIGITAL1:
			IsHaveExtPinPad();	 
			break;
		case DIGITAL2:
			SetSignPad();	 
			break;
		case DIGITAL3:
			LoadAkeyManu();
			break;
		case ESC:
			return ESC;
		default:
			break;
		}
	}
	return(ESC);
}

int DeleteFile(){
	int ret;
	ret = DelFile_Api(RECORDLOG);
	if (ret == 0)
	{
		ScrDisp_Api(LINE3,0,"Delete successful",CDISP);
		gCtrlParam.iTransNum = 0;

	}else{
		ScrDisp_Api(LINE3,0,"Delete fail",CDISP);
	}
	WaitKey_Api();
	return(ESC);
}

int SelectMainMenu(void)
{
	int key;   

	char maintitle[] = "Menu";
	const char *main_menu[] = {
		"1.Sale ",
		"2.Void ",
		"3.Balance Inquiry ",
		"4.Record",
		"5.Delete File"
	};
	while(1)
	{
		key = ShowMenuItem(maintitle, main_menu, 5, DIGITAL0, DIGITAL5, 0, 60);
		switch(key)
		{
		case DIGITAL0:
			SettingMenu();
			break;
		case DIGITAL1:
			PosCom.stTrans.Trans_id = POS_SALE;
			return 0;
		case DIGITAL2:								 
			PosCom.stTrans.Trans_id = POS_SALE_VOID;
			return 0;
		case DIGITAL3:	
			PosCom.stTrans.Trans_id = POS_QUE;		 
			return 0;
		case DIGITAL4:	
			ShowLogs();
			return 0;
		case DIGITAL5:	
			DeleteFile();	 
			return 0;
		case ESC:
			return ESC;
		default:
			break;
		}
	}
	return(ESC);
}



//0-string 1-bcd
void CommDebugInfo(char *title, unsigned char *Date, int DateLen, int flag)
{
#ifdef _OUTPUTLOG_
	char TempBuf[2048+1024];
	
	PortSends_Api(0, (char*)title, strlen(title));
	PortSends_Api(0, "\r\n", 2);
	if(flag == 0)
	{
		PortSends_Api(0, (char*)Date, DateLen);
		PortSends_Api(0, "\r\n", 2);
		return ;
	}
	BcdToAsc_Api(TempBuf, Date, DateLen*2);
	PortSends_Api(0, (char*)TempBuf, DateLen*2);
	PortSends_Api(0, "\r\n", 2);
#endif
}


int SetMaskterKeyValue(int flag)
{
	char Tempbuf[64];
	u8 sKey[16];
	u8 mainkeyidx;
	int nRet;

	memset(Tempbuf, 0,sizeof(Tempbuf));
	memset(sKey, 0, sizeof(sKey));

	if(gCtrlParam.MainKeyIdx <0 ||gCtrlParam.MainKeyIdx > 9 )
	{
		gCtrlParam.MainKeyIdx = 0;
		SaveCtrlParam();
	}
	mainkeyidx = gCtrlParam.MainKeyIdx;  //set 

	memset(Tempbuf, 0, sizeof(Tempbuf));
	memset(sKey, 0, sizeof(sKey));
	memset(Tempbuf, 0x31, 32);
	AscToBcd_Api(sKey, Tempbuf, 32);
	if(gCtrlParam.DesType == 0)//3des
	{
		if(gCtrlParam.pinpad_type == PIN_PP)
			nRet = PPWriteMKey_Api(mainkeyidx, 0x03, sKey);
		else
			nRet = PEDWriteMKey_Api(mainkeyidx, 0x03, sKey);	
	}
	else
	{
		if(gCtrlParam.pinpad_type == PIN_PP)
			nRet = PPWriteMKey_Api(mainkeyidx, 0x01, sKey);
		else
			nRet = PEDWriteMKey_Api(mainkeyidx, 0x01, sKey);		
	}

	if(flag != 0)
	{
		if(nRet != 0) 
			ErrorPrompt("masterKey write failed", 2);
		else
			ErrorPrompt("masterKey write ok", 2);
	}
	
}
int SetWorkKeyIdx(void)
{
	char Tempbuf[100];
	int nRet;

	memset(Tempbuf, 0, sizeof(Tempbuf));

	ScrCls_Api();
	DispTitle("trade key setting");
	sprintf(Tempbuf, "key index(0-9):%d", gCtrlParam.MainKeyIdx);
	ScrDisp_Api(LINE2, 0, Tempbuf, LDISP);
	memset(Tempbuf, 0, sizeof(Tempbuf));
	nRet = GetScanf(MMI_NUMBER, 1, 1, Tempbuf, 30, LINE4, LINE4, 16);
	if(nRet != ENTER)
		return -1;
	gCtrlParam.MainKeyIdx = Tempbuf[1]-0x30;
	SaveCtrlParam();
	return 0;
}



void SetPinkey(int flag)
{
	u8 PinKey[32], buf[64], ret;

	memset(buf, 0, sizeof(buf));
	memset(PinKey, 0, sizeof(PinKey));

	if ((gCtrlParam.DesType & 0x0f) == 0)
	{	
		strcpy(buf, "222222222222222222222222222222227B0205FF");
		AscToBcd_Api(PinKey, buf, 40);
		if(gCtrlParam.pinpad_type == PIN_PP )
			ret = PPWriteWKey_Api(gCtrlParam.MainKeyIdx, gCtrlParam.PinKeyIndes, 0x83, PinKey);
		else
			ret = PEDWriteWKey_Api(gCtrlParam.MainKeyIdx, gCtrlParam.PinKeyIndes, 0x83, PinKey);
	}
	else
	{
		strcpy(buf, "22222222222222227B0205FF");
		AscToBcd_Api(PinKey, buf, 24);
		if(gCtrlParam.pinpad_type == PIN_PP )
			ret = PPWriteWKey_Api(gCtrlParam.MainKeyIdx, gCtrlParam.PinKeyIndes, 0x81, PinKey);
		else
			ret = PPWriteWKey_Api(gCtrlParam.MainKeyIdx, gCtrlParam.PinKeyIndes, 0x81, PinKey);
	}

	if(flag != 0)
	{
		if(ret != 0)
			ErrorPrompt("pinkey write error!", 5);
		else
			ErrorPrompt("pinkey write ok!", 5);
	}	
}
int LoadAkeyManu(void)
{
	int key;
	char *Title = "key setting";
	const char *main_menu[] = {
		"1.Set MasterKey",		
		"2.Set Pinkey"
	};

	if(gCtrlParam.pinpad_type == PIN_PP)
		PPPowerOn_Api();

	ScrCls_Api();
	while(1)
	{			
		key = ShowMenuItem(Title, main_menu, 2, DIGITAL1, DIGITAL2, 0, 30);
		switch(key)
		{
		case DIGITAL1:	//input master key 
			SetMaskterKeyValue(1);
			break;
		case DIGITAL2:
			SetPinkey(1);
			break;
		case ESC:
			return ESC;
		}
	}

	if(gCtrlParam.pinpad_type == PIN_PP)
		PPPowerOff_Api();
	return(0);
}


int IsHaveExtPinPad(void)
{
	int ret;

	ret = ZeroOneSelectTwoLine("Pinpad Type", "PIN_PP", "PIN_PED", TRUE, gCtrlParam.pinpad_type, 30);
	if(ret == DIGITAL1) //是
	{
		gCtrlParam.pinpad_type = PIN_PP; 
		gCtrlParam.SupportPICC = EXPICCCARD;
		SaveCtrlParam();
	}
	else  if(ret == DIGITAL0) //否
	{
		gCtrlParam.pinpad_type = PIN_PED;
		gCtrlParam.SupportPICC = PEDPICCCARD;
		SaveCtrlParam();
	}
	return 0;
}


int ZeroOneSelectTwoLine(char *szTitle,char *choice1,char *choice0, BOOL IsDisOldSele, int OldSel, int iTimeOut)
{
	char buf[40];	
	int key;

	memset(buf, 0, sizeof(buf));

	ScrCls_Api();
	KBFlush_Api();

	DispTitle(szTitle);  
	sprintf(buf, "1-%s", choice1);
	ScrDisp_Api(LINE2, 0, buf, LDISP); 

	memset(buf, 0, sizeof(buf));
	sprintf(buf, "0-%s", choice0);
	ScrDisp_Api(LINE3, 0, buf, LDISP); 
	if(IsDisOldSele ==TRUE )
	{
		memset(buf, 0, sizeof(buf));
		sprintf(buf,"%d",OldSel);
		ScrDisp_Api(LINE4, 0, buf, RDISP); 
	}

	do
	{
		key = WaitAnyKey_Api(iTimeOut);
		if(key == -2)
			return -1;
	} while(key != ENTER && key != ESC && key!= DIGITAL1 && key!= DIGITAL0);
	return key;
}



void InitOper(void)
{
	if(GetFileSize_Api(FILE_OPER_LOG) == sizeof(gtOperator))
		return;

	// 
	memset(&gtOperator, 0, sizeof(OPER_STRC));
	gtOperator.nOptNO[0] = 0;
	strcpy(gtOperator.sOptPwd[0], "123456");
	gtOperator.nOptNO[1] = 99;
	strcpy(gtOperator.sOptPwd[1], "000000");
	gtOperator.nOptNO[2] = 1;
	strcpy(gtOperator.sOptPwd[2], "0000");
	gtOperator.nOptNO[3] = 2;
	strcpy(gtOperator.sOptPwd[3], "0000");
	gtOperator.nOptNO[4] = 3;
	strcpy(gtOperator.sOptPwd[4], "0000");
	gtOperator.nOptNO[5] = 4;
	strcpy(gtOperator.sOptPwd[5], "0000");
	gtOperator.nOptNO[6] = 5;
	strcpy(gtOperator.sOptPwd[6], "0000");

	SaveOperFile();
}

int CheckManagerPassWd(void)
{
	char PassWd[8];

	ScrClrLine_Api(LINE2, LINE5);	
	ScrDisp_Api(LINE2, 0, "Please input the ", LDISP);
	ScrDisp_Api(LINE3, 0, "supervisor password:", LDISP);
	memset( PassWd, 0, sizeof(PassWd) );
	if(GetScanf(MMI_NUMBER|MMI_PWD, 4, 6, PassWd, 60, LINE4, LINE4, 16) == ENTER )
	{
		if(strcmp(&PassWd[1], gtOperator.sOptPwd[0]) != 0)
		{
			ErrorPrompt("Password is wrong", 2);
			return 1;
		}
		else
			return 0;		
	}
	else 
		return 1;

	return 0;
}




int ReadOperFile(void)
{
	u32 FileLen;

	InitOper();
	FileLen = sizeof(gtOperator);
	ReadFile_Api(FILE_OPER_LOG, (u8*)&gtOperator, 0, &FileLen);
	return 0;
}

int SaveOperFile(void)
{
	char result ;
	u32 len;

	len = sizeof(OPER_STRC);  
	result = WriteFile_Api(FILE_OPER_LOG,(u8*)&gtOperator, 0, len);
	if(result == 0)						 
	{                                    
		return 0;                        
	}                                    
	else								 
	{                                    
		return (E_MEM_ERR);
	}
}











int GetCardNoFromTrack2Data(char *cardNo, u8 *track2Data)
{
	char tmp[MCARDNO_MAX_LEN + 2], *p = NULL ;
	u32 len;

	memset(tmp, 0, sizeof(tmp));

	len = MCARDNO_MAX_LEN+1 < track2Data[0]*2 ? MCARDNO_MAX_LEN+1 : track2Data[0]*2;

	FormBcdToAsc( tmp, track2Data+1, len);
	tmp[len] = '\0';
	p = strchr(tmp, '=');//
	if(p != NULL)
	{
		*p = 0;
		strcpy(cardNo, tmp);
		return TRUE;
	}

	return FALSE;
}


int ShowMenuItem(char *Title, const char *menu[], u8 ucLines, u8 ucStartKey, u8 ucEndKey, int IsShowX, u8 ucTimeOut)
{
	u8 IsShowTitle, cur_screen, OneScreenLines, Cur_Line, i, t;
	int nkey;
	char dispbuf[50];

	memset(dispbuf, 0, sizeof(dispbuf));

	if(Title != NULL)
	{
		IsShowTitle = 1;
		OneScreenLines = 4;
	}
	else
	{
		IsShowTitle = 0;
		OneScreenLines = 5;
	}
	IsShowX -= 1;	 
	cur_screen = 0;  
	while(1)
	{
		ScrClsRam_Api();
		if(IsShowTitle)
			DispTitle(Title);
		Cur_Line = LINE1+IsShowTitle;
		for(i = 0; i < OneScreenLines; i++) 
		{
			t = i+cur_screen*OneScreenLines;
			if (t >= ucLines || menu[t] == NULL)// 
			{
				break;
			}
			memset(dispbuf, 0, sizeof(dispbuf));
			strcpy(dispbuf, menu[t]);
			ScrDispRam_Api(Cur_Line++, 0, dispbuf, FDISP);
		}
		ScrBrush_Api();
		// 
		nkey = WaitAnyKey_Api(ucTimeOut);
		switch(nkey)
		{
		case UP:
#if ( defined(V70B_MACHINE) || defined(V80B_MACHINE) )
		case F2:
#endif
			if(cur_screen)
				cur_screen--;
			break;
		case DOWN:
#if ( defined(V70B_MACHINE) || defined(V80B_MACHINE) )
		case F3:
#endif
			if ((t < (ucLines-1) ) ) 
				cur_screen++;
			break;
		case ESC:
		case TIMEOUT:
			return nkey;
			break;
		default:
			if( (nkey >= ucStartKey)&&(nkey <= ucEndKey) )
				return nkey;
			break;
		}
	};
}

char GetNameFromTrack1(char *Inbuf, char *Name)
{
	int i, j, Nl;
	char *p = NULL ;

	i = 0;
	j = 0;
	while( Inbuf[i] != 0 )  // '~'
	{
		if( Inbuf[i] == 0x7e )//'~'
		{
			p = &Inbuf[i+1];
			break;  	
		}
		i++;
	}

	if(Inbuf[i] == 0 ) // '~', 
		return -1;

	while( *p != 0 )   
	{
		if( *p == 0x7e )//'~'			   
			break;
		Name[j++] = *p++;
		if(j >= 19) 
			break;
	}

	if( *p == 0 )  
		return -2;

	Nl = strlen(Name);
	for(i = 0, j = 0; i < Nl ; )
	{
		if( Name[j] != '@' )
		{
			Name[i] = Name[j];
			i++;
		}
		else
			Name[j] = 0;
		j++;
	}  
	return 0;
}

void InitPosCom(void)
{
	u8 TimeBuf[28];

	memset(&PosCom, 0, sizeof(POS_COM));
	memset(TimeBuf, 0, sizeof(TimeBuf));

	memcpy(PosCom.stTrans.MerchantNo, gCtrlParam.MerchantNo, 15);
	memcpy(PosCom.stTrans.TerminalNo, gCtrlParam.TerminalNo, 8);

	if(gCtrlParam.lTraceNo<=0 || gCtrlParam.lTraceNo > 999999)
	{
		gCtrlParam.lTraceNo = 1;
		SaveCtrlParam();
	}
	if(gCtrlParam.lNowBatchNum <= 0 || gCtrlParam.lNowBatchNum > 999999)
	{
		gCtrlParam.lNowBatchNum = 1;
		SaveCtrlParam();
	}

	memset(PosCom.stTrans.AuthCode, '0', 6);	
	PosCom.stTrans.lTraceNo = gCtrlParam.lTraceNo;
	PosCom.stTrans.lNowBatchNum = gCtrlParam.lNowBatchNum;	

	GetSysTime_Api(TimeBuf);                                 
	memcpy(PosCom.stTrans.TradeDate, TimeBuf, 4);			 
	memcpy(PosCom.stTrans.TradeTime, &TimeBuf[4], 3);        
	memset(TimeBuf,0,sizeof(TimeBuf));                       
	//                                                       
	PosCom.stTrans.EntryMode[1] = PIN_NOT_INPUT;			 
	PosCom.stTrans.OperatorNo = (u8)gtOperator.nCurOptNO;	 
}                                                            


void DispTitle(char* Title)
{
	char DisBuf[200];
	int Slen;
	unsigned char atr = NOFDISP|CDISP;

	memset(DisBuf, 0, sizeof(DisBuf));

	if(atr & NOFDISP)
	{
		memset(DisBuf, 0x20, sizeof(DisBuf));
		if(atr & CDISP) //居中
		{
			Slen = strlen(Title); 
			if(Slen > 21)
			{
				memcpy(DisBuf,Title, 21 );
			}
			else 
			{
				memcpy(&DisBuf[(21 - Slen)/2],Title, Slen );
			}
		}	
	}
	else
		strcpy(DisBuf, Title);

	ScrDisp_Api(LINE1, 0, DisBuf, atr);
	return;
}

void WaitRemoveICC(void)
{
	while(IccDetectOut_Api(ICC_EMV) != 0)
	{
		ScrClrLine_Api(LINE3, LINE3);
		ScrDisp_Api(LINE3, 0, "Please Pull Card", CDISP);
		Beep_Api(BEEPERROR);
	};
}

void DisplayProcessing(void)
{
	ScrClrLine_Api(LINE2, LINE5);
	ScrDisp_Api(LINE3, 0, "Processing", CDISP);
	ScrDisp_Api(LINE4, 0, "Please Wait", CDISP);
}

int GetScanf(u32 mode, int Min, int Max, char *outBuf, u32 TimeOut, u8 StartRow, u8 EndRow, int howstr) 
{
	return GetScanfEx_Api(mode, Min, Max, outBuf, TimeOut, StartRow, EndRow, howstr, MMI_NUMBER);
}

void MakeTimeDispBuf(char *pDisp, char *pStrTime)
{
	memcpy(&pDisp[0], &pStrTime[0], 4);
	memcpy(&pDisp[4], "/", 1);
	memcpy(&pDisp[5], &pStrTime[4], 2);
	memcpy(&pDisp[7], "/", 1);
	memcpy(&pDisp[8], &pStrTime[6], 2);
	memcpy(&pDisp[10], " ", 1);
	memcpy(&pDisp[11], &pStrTime[8], 2);
	memcpy(&pDisp[13], ":", 1);
	memcpy(&pDisp[14], &pStrTime[10], 2);
	memcpy(&pDisp[16], ":", 1);
	memcpy(&pDisp[17], &pStrTime[12], 2);
	pDisp[19] = 0;
}

void GetPanNumber()
{
	int tlvLen = 0, i,ret;
	u8 buf[64];
	u8 TEM[64];

	memset(buf, 0, sizeof(buf));
	memset(TEM, 0, sizeof(TEM));
	ret = Common_GetTLV_Api(0x5A, buf, &tlvLen);
	if(ret == 0) // 
	{
		BcdToAsc_Api(PosCom.stTrans.MainAcc, buf, tlvLen * 2);
		for(i = tlvLen * 2 - 1; i >= 0; --i)
		{
			if(PosCom.stTrans.MainAcc[i] == 'F' || PosCom.stTrans.MainAcc[i] == 'f')
				PosCom.stTrans.MainAcc[i] = 0;
			else
				break;
		}
	}
	else
	{
		ret = Common_GetTLV_Api(0x57, buf, &tlvLen);
		if (ret == 0)
		{
			
			BcdToAsc_Api(TEM, buf, tlvLen * 2);
			for(i = tlvLen * 2 - 1; i >= 0; --i)
			{
				if(TEM[i] == 'D'){
					TEM[i] = 0;
					memcpy(PosCom.stTrans.MainAcc,TEM, i);
					break;
				}
			}
		}
	}

}



